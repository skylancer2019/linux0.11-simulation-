# linux0.11-simulation-
simulate what linux0.11 would do about process and memory when a simple program is running
## 仿真内容
以linux0.11中进程、内存、系统调用相关的代码为核心，描述了某个简单程序在linux0.11运行时的操作序列。通过图形化的方式展示整个过程，会体现出进程的fork、execve、schedule、release, 内存的缺页和写保护异常等过程，也会涉及到文件系统相关的内容。
## 相关知识
-操作系统原理(80\%)
-计算机组成(30\%)
-计算机体系结构(30\%)
-数据结构(30\%)
-汇编语言(50\%)等基本知识和方法

## 内核运行数据输出方法
数据提取工具为gdb调试工具，在linux0.11源代码中打断点，从而提取出内核运行相关的信息。data文件夹中的ff.c文件是需要在linux0.11中运行的文件，断点用于监测该程序运行过程中linux内核所干的事情。采用虚拟机中提供的edit\_rootfs\_hd函数，将ff.c文件移动到usr/root文件夹下。在设置断点之前，用虚拟机提供的函数run\_gdb\_script\_hd\_console\_livedisplay将ff.c文件通过gcc编译成可执行文件fff。之后从data文件夹下找到new 1与new 2文件，这两个文件都是断点文件。将两个断点文件的内容输入gdb\_script\_beforeboot文件中。运行虚拟机中的函数run\_gdb\_script\_hd\_console\_redirect，在命令行输入./fff，待程序运行结束后退出linux0.11。此时虚拟机桌面上得到gdb\_output.txt文件，该文件中为提取出的初始数据。

将gdb\_output.txt文件更名为debug.txt。在debug文件中找到进程4创建新进程的系统调用，在该系统调用前一行加上"-------------------------begin"字段。同样在debug文件中找到release最后一个进程(一般为进程6)的系统调用的结束处(一般为某个ret\_from\_sys\_call结束处)，空出一行后，加上"-----------------------end"字段。用于人工标记考虑的数据的起始和终止位置。

从data文件夹中取出transferOS.java文件，将transferOS文件放在某个java package中，在文件首加上"package 包名;"，使得该java代码可以在当前包下运行。将debug文件放在D盘下，运行transferOS.java，该程序将会输出中间文件temp\_data.txt,real\_datan.txt,以及目标文件input.txt。将input.txt文件移动到data文件夹下。检查input.txt文件，保证每两个数据区之间的空行为一个(生成的文件中可能数据区间隔为多行)，同时也要将包含“---in copy\_page\_tables”的相邻断点区域合为一个，即删除其中靠后的断点区域的前4行，之后再删除两个断点区域之间的空行。

处理好input.txt后，用visual studio打开WinOSTest.sln文件并运行，即可生成动画。

## 可视化方法描述
### 使用的工具
采用winform编写整个程序，使用了winform的基础控件，在基础控件的基础上利用c\#自带的drawing库完成图像绘制。
### 工作原理
将从linux0.11内核中提取出的数据文件debug.txt作为java程序transferOS.java的输入，完成对初始数据的过滤和规范化，输出可视化程序的输入文件input.txt。可视化程序WinOSTest将读入input.txt文件，根据文件中的内容生成动画。debug.txt与input.txt都在data文件夹下，而data文件夹位于zip包的winOSTest文件夹下。
### 实现功能
根据读入的数据，决定当前正在展示的过程，以及接下来将要展示的过程。即动画展示的操作的顺序和内容都是数据驱动的。程序中有四个绘图pictureBox(可视为绘图窗口),分别负责展示进程信息，展示寄存器作用，展示堆栈状态和小区域绘图，大区域绘图。绘图窗口之间会根据需要互相切换显示。

展示内存相关内容时，表现的内存区中和当前过程相关的地址会被展示。展示的内存区的大小、比例会根据读入数据中按比例展示。例如：展示copy\_pahe\_tables时候，会根据页目录项在页目录中的地址和1024的比值，以及页目录绘制的起点，得到页目录项在屏幕上应当绘制的位置，从而绘制出页目录项。即展示的数据是数据驱动的，绘制出的图像的比例也是数据驱动的。

展示过程大部分采用动画的形式，辅以一些固定要展示相关数据（譬如寄存器的值）。对于各个过程会采用逐步推出的方式展示每一步应当做的动作，使得整个展示的信息量更加丰富，也使得展示更加直观。对于一些固定会展示的数据：采用圆和箭头的形式实时展示出相关进程之间的关系和所处状态。显示当前过程所在的函数，以及当前各个寄存器的值和堆栈的状态。

在过程相关动画展示结束之后，会输出进程的线性地址空间中哪些部分发生了缺页异常，哪些部分发生了写保护异常。展示了一个较为完整的程序运行过程，可以发现出现缺页异常和写保护异常的规律，以及各个操作之间的顺序关系。

### 编译、配置、运行的具体方法
编译时使用visual stduio,直接进入代码压缩包中的WinsOSTest.sln文件，运行该文件。运行时应当保证input.txt输入文件在WinOSTest/data文件夹下。并且需要保证input.txt文件中各个数据区之间的间隔为一个空行(不能为多个)。

## 系统运行过程的具体描述
过程主要展示了运行一个用户程序时的进程控制和调度的具体操作，以及与它们相关的内存变化。同时也会包含页异常处理，文件系统相关的内容和涉及的系统调用的展示。假设登陆Shell运行在进程4，则在命令行输入程序并开始运行时，会创建新的进程6，进程4在继续运行的过程中会产生写保护异常。进程4通过schedule切换到进程6，进程6发生写保护异常，进程6设置一些信号的句柄，进程6 execve开始真正执行用户程序。进程6发生缺页异常，之后打开文件，打开文件后又发生缺页异常。缺页异常与重设数据段末尾交替进行，后尝试对文件输入输出进行控制。进程6创建进程7，进程6发生写保护异常，之后尝试输入输出控制。输入输出设置成功后，进程6开始调用sys\_write向终端写入字符。第一次sys\_write会引发写保护异常，之后进行用户循环中要求的次数的sys\_write。在最后一次向终端写入字符后，sys\_write中调用file\_write,进行文件写入。进程6关闭打开的文件并exit,将进程7挂在进程1下，schedule到进程7。刚进入进程7时，进程7发生写保护异常，之后进行输入输出设置。输入输出设置之后进行sys\_write,具体过程与进程6时相同。进程7退出之后，schedule到进程1，进程1中彻底释放进程7，进程1调用sys\_waitpid,schedule到进程4，进程4收到SIGCHILD,发生写保护异常，释放进程6.

## 其他内容
见README.pdf
