% !TeX spellcheck = <none>
% !TeX encoding = UTF-8
\documentclass[]{report}

\usepackage{caption}
\usepackage{color}
\usepackage{ctex}
\usepackage{enumerate}
\usepackage{fontspec}
\usepackage[bottom]{footmisc}
\usepackage{graphicx}
\usepackage[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black]{hyperref}
\usepackage{listings}
\usepackage{titletoc}
\usepackage{float}
\usepackage{ltxtable,filecontents}
%\usepackage{titlesec}

\setCJKfamilyfont{rm}{Microsoft YaHei}
\setCJKfamilyfont{tt}{Microsoft YaHei}
\setmainfont{DejaVu Sans Mono}

%修改命名
\renewcommand{\chaptername}{}
\renewcommand{\partname}{}
\titlecontents{chapter}[0.5cm]{\bf\vspace{10pt}}{\contentslabel{0.5cm}}{}{~\titlerule*[0.6pc]{$.$}~\contentspage}
\titlecontents{section}[1.5cm]{}{\contentslabel{1cm}}{}{~\titlerule*[0.6pc]{$.$}~\contentspage}
\titlecontents{subsection}[2.5cm]{}{\contentslabel{1.5cm}}{}{~\titlerule*[0.6pc]{$.$}~\contentspage}

%代码高亮设置
\lstset{
    basicstyle=\small\ttfamily\fontspec{DejaVu Sans Mono},
    frame=tb,
    keywordstyle=\color[RGB]{40,40,255},
    commentstyle=\it\color[RGB]{0,96,96},
    stringstyle=\rmfamily\slshape\color[RGB]{128,0,0}
}
\renewcommand*\thelstnumber{\arabic{lstnumber}:}
\DeclareCaptionFormat{mylstcap}{\hrule height1.5pt#1#2#3}
\captionsetup[lstlisting]{format=mylstcap,labelfont=bf,singlelinecheck=off,labelsep=space}
\renewcommand{\lstlistingname}{代码}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{\lstlistingname列表}% List of Listings -> List of Algorithms
%\floatname{algorithm}{算法}

\title{linux0.11 simulation}


\begin{document}


\section{仿真内容}
以linux0.11中进程、内存、系统调用相关的代码为核心，描述了某个简单程序在linux0.11运行时的操作序列。通过图形化的方式展示整个过程，会体现出进程的fork、execve、schedule、release, 内存的缺页和写保护异常等过程，也会涉及到文件系统相关的内容。

\section*{Linux操作系统为背景，涉及}
\begin{enumerate}[-]
	\item 操作系统原理(80\%)
	\item 计算机组成(30\%)
	\item 计算机体系结构(30\%)
	\item 数据结构(30\%)
	\item 汇编语言(50\%)等基本知识和方法
\end{enumerate}


%\setcounter{chapter}{0}

\chapter{内核运行数据输出方法}
数据提取工具为gdb调试工具，在linux0.11源代码中打断点，从而提取出内核运行相关的信息。data文件夹中的ff.c文件是需要在linux0.11中运行的文件，断点用于监测该程序运行过程中linux内核所干的事情。采用虚拟机中提供的edit\_rootfs\_hd函数，将ff.c文件移动到usr/root文件夹下。在设置断点之前，用虚拟机提供的函数run\_gdb\_script\_hd\_console\_livedisplay将ff.c文件通过gcc编译成可执行文件fff。之后从data文件夹下找到new 1与new 2文件，这两个文件都是断点文件。将两个断点文件的内容输入gdb\_script\_beforeboot文件中。运行虚拟机中的函数run\_gdb\_script\_hd\_console\_redirect，在命令行输入./fff，待程序运行结束后退出linux0.11。此时虚拟机桌面上得到gdb\_output.txt文件，该文件中为提取出的初始数据。\\

将gdb\_output.txt文件更名为debug.txt。在debug文件中找到进程4创建新进程的系统调用，在该系统调用前一行加上"-------------------------begin"字段。同样在debug文件中找到release最后一个进程(一般为进程6)的系统调用的结束处(一般为某个ret\_from\_sys\_call结束处)，空出一行后，加上"-----------------------end"字段。用于人工标记考虑的数据的起始和终止位置。如下图所示：
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{os12}  
	\caption{begin位置}  %图片的名称
	\label{fig14}
\end{figure}

\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{os11}  
	\caption{end位置}  %图片的名称
	\label{fig15}
\end{figure}

从data文件夹中取出transferOS.java文件，将transferOS文件放在某个java package中，在文件首加上"package 包名;"，使得该java代码可以在当前包下运行。将debug文件放在D盘下，运行transferOS.java，该程序将会输出中间文件temp\_data.txt,real\_datan.txt,以及目标文件input.txt。将input.txt文件移动到data文件夹下。检查input.txt文件，保证每两个数据区之间的空行为一个(生成的文件中可能数据区间隔为多行)，同时也要将包含“---in copy\_page\_tables”的相邻断点区域合为一个，即删除其中靠后的断点区域的前4行，之后再删除两个断点区域之间的空行。\\

处理好input.txt后，用visual studio打开WinOSTest.sln文件并运行，即可生成动画。
文件存放位置结构如下：
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{os13}  
	\caption{winOSTest文件夹下}  %图片的名称
	\label{fig16}
\end{figure}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{osc}  
	\caption{data文件夹下}  %图片的名称
	\label{fig17}
\end{figure}

\chapter{可视化方法的描述}

\section{使用的工具}
采用winform编写整个程序，使用了winform的基础控件，在基础控件的基础上利用c\#自带的drawing库完成图像绘制。

\section{工作原理}
将从linux0.11内核中提取出的数据文件debug.txt作为java程序transferOS.java的输入，完成对初始数据的过滤和规范化，输出可视化程序的输入文件input.txt。可视化程序WinOSTest将读入input.txt文件，根据文件中的内容生成动画。debug.txt与input.txt都在data文件夹下，而data文件夹位于zip包的winOSTest文件夹下。
\section{实现功能}
根据读入的数据，决定当前正在展示的过程，以及接下来将要展示的过程。即动画展示的操作的顺序和内容都是数据驱动的。程序中有四个绘图pictureBox(可视为绘图窗口),分别负责展示进程信息，展示寄存器作用，展示堆栈状态和小区域绘图，大区域绘图。绘图窗口之间会根据需要互相切换显示。\\
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{xg}  
	\caption{各个绘图窗口}  %图片的名称
	\label{fig444}
\end{figure}

展示内存相关内容时，表现的内存区中和当前过程相关的地址会被展示。展示的内存区的大小、比例会根据读入数据中按比例展示。例如：展示copy\_pahe\_tables时候，会根据页目录项在页目录中的地址和1024的比值，以及页目录绘制的起点，得到页目录项在屏幕上应当绘制的位置，从而绘制出页目录项。即展示的数据是数据驱动的，绘制出的图像的比例也是数据驱动的。\\

展示过程大部分采用动画的形式，辅以一些固定要展示相关数据（譬如寄存器的值）。对于各个过程会采用逐步推出的方式展示每一步应当做的动作，使得整个展示的信息量更加丰富，也使得展示更加直观。对于一些固定会展示的数据：采用圆和箭头的形式实时展示出相关进程之间的关系和所处状态。显示当前过程所在的函数，以及当前各个寄存器的值和堆栈的状态。\\

在过程相关动画展示结束之后，会输出进程的线性地址空间中哪些部分发生了缺页异常，哪些部分发生了写保护异常。展示了一个较为完整的程序运行过程，可以发现出现缺页异常和写保护异常的规律，以及各个操作之间的顺序关系。
\section{程序架构}
\subsection{程序主体}
该程序主体为timer1\_Tick函数，该函数和一个Timer挂钩，每隔1s就会调用一次该函数。一个timer1过程会完成一个断点区域的读入(即input文件中两个空格之间的断点区域，可能包含一个或多个断点)。timer1\_Tick函数会进行一系列判断，例如是否需要重绘窗口(当从另一个窗口返回时需要重绘)，是否有上一个断点区域多读的数据存储在缓冲区中等。timer1\_Tick在第一次读入数据时，根据读入\_\_\_pid字段的值，绘制初始的进程节点。之后，该函数会进入循环，不断从input文件逐行读入数据，根据读入数据的范围(即所在的linux函数)和当前数据标识符，选择处理该数据的方式，进行处理；直到读空，该断点区域结束。下图为循环的部分代码：
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{os2}  
	\caption{循环部分代码}  %图片的名称
	\label{fig4}
\end{figure}
上图循环中多通过对range所包含的字符串进行判断从而进行分支处理。循环中选择的处理方式可能直接在循环中完成处理，也可能转到其他子函数去解决。

\subsection{主体架构}
timer1\_tick在循环中读入range，发现进入一个较为完整的大过程时，会转入对应的子函数处理。具体架构如下：
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{os1}  
	\caption{主体架构}  %图片的名称
	\label{fig5}
\end{figure}
上图中各个模块的名称对应于linux0.11元代码中的一个过程，而这个模块就是用于处理和对应的过程相关的读入数据，完成图像的绘制。例如图中CopyPage就是用于完成linux函数copy\_page\_tables过程的动画绘制。un\_wp\_page就是用于绘制写保护异常时的操作过程。此外该程序中还包含一些被引用较多次数的工具函数。\\

\subsection{工具函数}
drawArrow()函数封装了drawing中的绘图函数，能够绘制不同方向和长度的箭头。DrawStack函数根据输入参数绘制不同长度的空栈。clearStack函数通过调用DrawStack采用重绘的方式清空堆栈。stacksmaller和stackLonger用于调整堆栈长度，pushStack和popStack用于对显示的堆栈进行push和pop。buildNewNode用于绘制新的进程节点，registerShow用于根据不同的寄存器信息，在屏幕上不同的寄存器窗口显示数值。clearAll用于清空除了显示进程的所有绘图区域，以及所有的寄存器窗口。还有一些上述子模块的功能性子函数。\\

\subsection{全局参数}
程序中的各个函数通过一些全局参数进行控制和数据交流，各个绘图窗口的切换状态也是通过全局参数的值进行判断。由于展示的过程涉及多个进程，展示某个过程时可能需要用到从之前数据读入的数据值。故而程序代码以全局参数的形式一定程度上模拟了task\_struct,记录从数据中提取出的进程相关信息。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{os3}  
	\caption{模拟task\_struct}  %图片的名称
	\label{fig6}
\end{figure}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{os4}  
	\caption{模拟task\_struct}  %图片的名称
	\label{fig7}
\end{figure}
rebuildpic1参数用于判断是否重绘展示进程相关信息的窗口，rebuildpic2用于判断是否重绘堆栈。重绘堆栈时需要借助全局栈drawStack记录的值来进行重绘。即该程序中也模拟了内核栈。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{os5}  
	\caption{重绘窗口}  %图片的名称
	\label{fig8}
\end{figure}


\section{最终效果以及相关截图}
进程相关关系和状态展示窗口效果：用颜色表示进程的状态，箭头表示进程间的父子关系，箭头的from端表示父进程，to端表示子进程。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{os6}  
	\caption{进程窗口}  %图片的名称
	\label{fig9}
\end{figure}
堆栈绘制和小范围动画效果：堆栈长度和显示会随当前系统调用过程而改变，堆栈右侧区域用于显示展示当前过程的动画。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{os7}  
	\caption{}  %图片的名称
	\label{fig10}
\end{figure}
展示寄存器信息的绘图窗口效果：在对应寄存器的右侧以不同的颜色显示当前寄存器内容的含义。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{os9}  
	\caption{}  %图片的名称
	\label{fig12}
\end{figure}
大绘图区域的展示效果：将整个显示窗口用于绘图
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.25]{os8}  
	\caption{}  %图片的名称
	\label{fig11}
\end{figure}
整体展示效果：上述大绘图区域和下面的整体区域之间的显示关系是切换的。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.25]{os10}  
	\caption{}  %图片的名称
	\label{fig13}
\end{figure}
进程的内存展示窗口：用于展示出现缺页异常和写保护异常的页面的位置
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.5]{os17}  
	\caption{}  %图片的名称
	\label{fig18}
\end{figure}
\section{编译、配置、运行的具体方法}
编译时使用visual stduio,直接进入代码压缩包中的WinsOSTest.sln文件，运行该文件。运行时应当保证input.txt输入文件在WinOSTest/data文件夹下。并且需要保证input.txt文件中各个数据区之间的间隔为一个空行(不能为多个)。

\chapter{系统运行过程的形式化描述方法}

\section{描述}

过程主要展示了运行一个用户程序时的进程控制和调度的具体操作，以及与它们相关的内存变化。同时也会包含页异常处理，文件系统相关的内容和涉及的系统调用的展示。假设登陆Shell运行在进程4，则在命令行输入程序并开始运行时，会创建新的进程6，进程4在继续运行的过程中会产生写保护异常。进程4通过schedule切换到进程6，进程6发生写保护异常，进程6设置一些信号的句柄，进程6 execve开始真正执行用户程序。进程6发生缺页异常，之后打开文件，打开文件后又发生缺页异常。缺页异常与重设数据段末尾交替进行，后尝试对文件输入输出进行控制。进程6创建进程7，进程6发生写保护异常，之后尝试输入输出控制。输入输出设置成功后，进程6开始调用sys\_write向终端写入字符。第一次sys\_write会引发写保护异常，之后进行用户循环中要求的次数的sys\_write。在最后一次向终端写入字符后，sys\_write中调用file\_write,进行文件写入。进程6关闭打开的文件并exit,将进程7挂在进程1下，schedule到进程7。刚进入进程7时，进程7发生写保护异常，之后进行输入输出设置。输入输出设置之后进行sys\_write,具体过程与进程6时相同。进程7退出之后，schedule到进程1，进程1中彻底释放进程7，进程1调用sys\_waitpid,schedule到进程4，进程4收到SIGCHILD,发生写保护异常，释放进程6.

\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.6]{fzy}  
	\caption{用户程序}  %图片的名称
	\label{fig2}
\end{figure}

\section{细节}

\begin{longtable}{|p{30pt}|p{190pt}|p{130pt}|p{30pt}|}
    \hline 
    编号 & 动作 & 事件 & 完成度 \\ 
    \hline 
    (1) &
    \begin{tabular}{c}
        调用系统调用，将用户栈的寄存器\\压入内核栈
    \end{tabular}
    &
    \begin{tabular}{c}
        进程由用户态进入内核态
    \end{tabular}
    & √ \\  %× 部分完成  新增
    \hline 
    (2) &
    \begin{tabular}{c} 压入刚进入系统调用时候的寄存\\器的值保存
    \end{tabular} &
	\begin{tabular}{c} 
		进程压栈 
	\end{tabular}& √ \\ 
    \hline 
    (3) &\begin{tabular}{c} Ds,ss,es都指向内核段，fs指\\向原数据段 
    \end{tabular} 
	&\begin{tabular}{c} 修改段寄存器 
    \end{tabular}& √ \\ 
    \hline 
    (4) &\begin{tabular}{c} 通过find\_empty\_process\\找到空闲的任务号与pid,压入堆栈\\copy\_process需要的参数
    \end{tabular} & 进程调用sys\_fork &√\\ 
    \hline
    (5) &
    \begin{tabular}{c}调用get\_free\_page从主内存\\区中获取空闲物理页面。复制原页面\\的任务数据结构到新内存页中
    \end{tabular}  &进程获得新的内存页  &√  \\ 
    \hline 
    (6) &
    \begin{tabular}{c}
    	Task\_struct更改，得到新任务在\\GDT表中的LDT段描述符的选择符值。
    \end{tabular}  &
    \begin{tabular}{c}
		修改新进程的任务数据结\\构,新进程进入不可中断\\等待状态
    \end{tabular}  &√  \\ 
    \hline 
    (7) &
    \begin{tabular}{c}
    	根据64MB*任务号得到新\\
    	进程在线性空间中的基地\\
    	址。由此设置局部描述符\\
    	表中的基地址。
    \end{tabular}  &
    \begin{tabular}{c}
    	设置新进程的位置
    \end{tabular}  &√  \\ 
    \hline 
    (8) &
    \begin{tabular}{c}
    	得到from\_dir与to\_dir,\\
    	from\_page\_table,为每一个\\
    	要复制的页表to\_page\_table\\
    	用get\_free\_page分配内存页
    \end{tabular}  &
    \begin{tabular}{c}
    	新进程复制页目录项\\和页表项
    \end{tabular}  &√  \\ 
    \hline 
    (9) &
    \begin{tabular}{c}
    	根据TSS与LDT在GDT表中
    	\\
    	的位置以及自身的基地址
    	\\
    	设置描述符的值并放入GDT表
    \end{tabular}  &
    \begin{tabular}{c}
    	在GDT表中设置新的
    	\\TSS与LDT
    \end{tabular}  &√  \\ 
    \hline 
    (10) &
    \begin{tabular}{c}
    	State=TASK\_RUNNING，
    	\\
    	弹出内核堆栈的内容：
    	\\
    	addl \$20,\%esp
    \end{tabular}  &
    \begin{tabular}{c}
    	新进程建立完成
    \end{tabular}  &√  \\ 
    \hline 
    (11) &
    \begin{tabular}{c}
    	压入系统调用返回值
    \end{tabular}  &
    \begin{tabular}{c}
    	返回原进程进行
    	\\
    	进程创建的后续工作
    \end{tabular}  &√  \\ 
    \hline 
    (12) &
    \begin{tabular}{c}
    	获取当前进程的状态和时
    	\\
    	间片，判断是进行reschedule
    	\\
    	还是进行ret\_from\_sys\_call
    \end{tabular}  &
    \begin{tabular}{c}
    	system\_call后续处理
    \end{tabular}  &√  \\ 
    \hline
    (13) &
    \begin{tabular}{c}
    	将ret\_from\_sys\_call压入堆栈，\\长跳转到schedule执行
    \end{tabular}  &
    \begin{tabular}{c}
    	重新调度
    \end{tabular}  &√  \\ 
    \hline
    (14) &
    \begin{tabular}{c}
    	将当前任务指针放入eax通过eax
    	\\
    	得到当前进程的相关状态，\\
    	判断进程是否为task0.
    \end{tabular}  &
    \begin{tabular}{c}
    	执行ret\_from\_sys\\
    	\_call
    \end{tabular}  &√  \\ 
    \hline
    
    (15) &\begin{tabular}{c}
    判断任务是否是用户任务
    \end{tabular}  &
    \begin{tabular}{c}
    	执行ret\_from\_sys\\
    	\_call
    \end{tabular}  &√  \\ 
	\hline
	(16) &\begin{tabular}{c}
		得到信号位图和阻塞码，得到要发出的信\\号。信号值入栈，执行do\_signal
	\end{tabular}  &
	\begin{tabular}{c}
		执行ret\_from\_sys\\
		\_call
	\end{tabular}  &√  \\ 
	\hline
	(17) &\begin{tabular}{c}
		弹出内核栈软件压入和硬件压入的内容。
	\end{tabular}  &
	\begin{tabular}{c}
		从系统调用返回调用程序
	\end{tabular}  &√  \\ 
	\hline
	(18) &\begin{tabular}{c}
		根据signr得到信号结构，判断该信号\\是否需要处理。
	\end{tabular}  &
	\begin{tabular}{c}
		对某个进程的信号进行处理
	\end{tabular}  &部分完成  \\ 
	\hline
	(19) &\begin{tabular}{c}
		将eip指向信号处理句柄
	\end{tabular}  &
	\begin{tabular}{c}
		对某个进程的信号进行处理
	\end{tabular}  &部分完成  \\ 
	\hline
	(20) &\begin{tabular}{c}
		将原调用程序的用户堆栈向下拓展，并
		\\
		通过verify\_area进行检查。若检查
		\\
		成功，则向用户堆栈放入数据。
	\end{tabular}  &
	\begin{tabular}{c}
		对某个进程的信号进行处理
	\end{tabular}  &部分完成  \\ 
	\hline
	(21) &
	\begin{tabular}{c}
		根据页边界对齐开始地址，对每个页面\\执行write\_verify操作
	\end{tabular}  &
	\begin{tabular}{c}
		Verify\_area
		\\内存验证
	\end{tabular}  &部分完成  \\ 
	\hline
	(22) &
	\begin{tabular}{c}
		取出对应页目录项，判断页是否存在
	\end{tabular}  &
	\begin{tabular}{c}
		写页面验证
	\end{tabular}  &部分完成  \\ 
	\hline
	(23) &
	\begin{tabular}{c}
		得到页表地址和页表中的偏移，从而得
		\\
		到页表项指针，判断标志位，若页面不
		\\
		可写且存在则执行写时复制
	\end{tabular}  &
	\begin{tabular}{c}
		写页面验证
	\end{tabular}  &部分完成  \\ 
	\hline
	(24) &\begin{tabular}{c}
		查询所有任务的alarm值，对过期信号
		\\
		发送SIGALARM信号。
	\end{tabular}  &
	\begin{tabular}{c}
		进程调度
	\end{tabular}  &√  \\ 
	\hline
	(25) &\begin{tabular}{c}
		循环比较所有任务的运行时间
		\\
		counter,选择counter最大的任务。
		\\
		若counter为0则更新所有任务的
		\\
		counter再进行计算。
	\end{tabular}  &
	\begin{tabular}{c}
		进程调度
	\end{tabular}  &√  \\ 
	\hline
	(26) &\begin{tabular}{c}
		switch\_to调度查询到的任务执行
	\end{tabular}  &
	\begin{tabular}{c}
		进程调度
	\end{tabular}  &√  \\ 
	\hline
	(27) &\begin{tabular}{c}
		遍历任务数组判断是否有处于可中断状
		\\
		态的具有非阻塞信号的任务
	\end{tabular}  &
	\begin{tabular}{c}
		进程调度
	\end{tabular}  &新增  \\ 
	\hline
	(28) &\begin{tabular}{c}
	通过system\_call进入系统调用，再调用
	\\
	\_sys\_execve。将指向eip的指针入栈，
	\\
	调用\_do\_execve.
	\end{tabular}  &
	\begin{tabular}{c}
		新进程调用execve
	\end{tabular}  &√  \\ 
	\hline
	(29) &\begin{tabular}{c}
		检测原进程的CS值，设置参数环境空
		
		\\
		间指针，初始化参数空间，根据要执行的
		\\
		程序的名称得到inode节点。
	\end{tabular}  &
	\begin{tabular}{c}
		Execve从命令行得到要执
		\\
		行的程序的名称和参数
	\end{tabular}  &√  \\ 
	\hline
	(30) &\begin{tabular}{c}
		检测文件是否为常规文件
	\end{tabular}  &
	\begin{tabular}{c}
		Execve检测文件的类型
	\end{tabular}  &√  \\ 
	\hline
	(31) &\begin{tabular}{c}
		判断inode节点中是否设置了
		\\
		S\_ISUID与S\_ISGID
	\end{tabular}  &
	\begin{tabular}{c}
		Execve判断是否改变当前
		\\
		权限
	\end{tabular}  &√  \\ 
	\hline
	(32) &\begin{tabular}{c}
		根据inode节点得到文件的uid
		\\
		和gid,与当前进程的uid和gid
		\\
		比较。
	\end{tabular}  &
	\begin{tabular}{c}
		Execve检测执行文件的
		\\
		权限
	\end{tabular}  &√  \\ 
	\hline
	(33) &\begin{tabular}{c}
		调用copy\_strings将参数字符串和
		\\
		环境字符串从高到低存放。若参数
		\\
		环境空间中没有内存页面，则要申请
		\\
		内存页面
	\end{tabular}  &
	\begin{tabular}{c}
		Execve设置参数和
		\\
		环境空间
	\end{tabular}  &√  \\ 
	\hline
	(34) &\begin{tabular}{c}
		释放代码段和数据段原来占用的
		\\
		页表和内存 
	\end{tabular}  &
	\begin{tabular}{c}
		Execve为执行程序修改
		\\
		进程状态
	\end{tabular}  &√  \\ 
	\hline
	(35) &\begin{tabular}{c}
		修改ldt表中的描述符，将参数
		\\
		和环境空间页面存放在数据段末端
	\end{tabular}  &
	\begin{tabular}{c}
		Execve为执行程序修改
		\\
		进程状态
	\end{tabular}  &√  \\ 
	\hline
	(36) &\begin{tabular}{c}
		在栈空间中创建环境和参数变量指针
		\\
		表。修改进程各个字段和新执行文件
		\\
		有关的信息
	\end{tabular}  &
	\begin{tabular}{c}
		Execve为执行程序修改
		\\
		进程状态
	\end{tabular}  &√  \\ 
	\hline
	(37) &\begin{tabular}{c}
		修改内核栈上的返回地址为新执行程序
		\\
		的入口，替换栈指针。返回
		\\
		\_sys\_execve,丢弃内核栈中的
		\\
		内容，执行系统调用的返回
	\end{tabular}  &
	\begin{tabular}{c}
		Execve执行程序
	\end{tabular}  &√  \\ 
	\hline
	(38) &\begin{tabular}{c}
		进程调用sys\_alarm设置报警时间。
		\\
		调用sigsuspend()挂起进程，直到有
		\\
		信号到达
	\end{tabular}  &
	\begin{tabular}{c}
		进程通过sleep()
		\\
		进入睡眠
	\end{tabular}  &×  \\ 
	\hline
	(39) &\begin{tabular}{c}
		进程调度时检查所有的alarm，当ala
		\\
		rm到达时，向对应任务发送SIGALA
		\\
		RM,使得sleep()的进程被唤醒。
	\end{tabular}  &
	\begin{tabular}{c}
		进程通过sleep()
		\\
		进入睡眠
	\end{tabular}  &×  \\ 
	\hline
	(40) &\begin{tabular}{c}
		调用\_page\_fault,修改段寄存器的
		\\
		值，取出引起页异常的线性地址，根据
		\\
		标志位判断引起异常的原因。
	\end{tabular}  &
	\begin{tabular}{c}
		发生页错误
	\end{tabular}  &√  \\ 
	\hline
	(41) &\begin{tabular}{c}
		申请物理内存，计算缺页所在的文件数
		\\
		据块号，用bread\_page将逻辑块读入
		\\
		物理页面中。将物理页面映射到指定的
		\\
		线性地址处。
	\end{tabular}  &
	\begin{tabular}{c}
		缺页处理
	\end{tabular}  &√  \\ 
	\hline
	(42) &\begin{tabular}{c}
		调用put\_page,根据线性地址计算
		\\
		它的页表地址。若页表项无效，则申请
		\\
		空闲页面。在页表中设置相关页表项内
		\\
		容。
	\end{tabular}  &
	\begin{tabular}{c}
		将物理页面映射
		\\
		到线性地址
	\end{tabular}  &√  \\ 
	\hline
	(43) &\begin{tabular}{c}
		弹出之前压入堆栈的参数，退出中断。
	\end{tabular}  &
	\begin{tabular}{c}
		缺页处理结束
	\end{tabular}  &√  \\ 
	\hline
	(44) &\begin{tabular}{c}
		page\_fault调用do\_wp\_page进行
		\\
		写保护异常处理。在地址不位于代码空
		\\
		间时调用un\_wp\_page进行处理。
	\end{tabular}  &
	\begin{tabular}{c}
		写保护异常
	\end{tabular}  &新增  \\ 
	\hline
	(45) &\begin{tabular}{c}
		判断线性地址所在页面的属性，若为共
		\\
		享页面则申请一页新的内存，使线性地
		\\
		址对应页表项指向新页面。
	\end{tabular}  &
	\begin{tabular}{c}
		写保护异常
	\end{tabular}  &新增  \\ 
	\hline
	(46) &\begin{tabular}{c}
		复制原页面到新页面
	\end{tabular}  &
	\begin{tabular}{c}
		写保护异常
	\end{tabular}  &新增  \\ 
	\hline
	(47) &\begin{tabular}{c}
		搜索文件结构指针数组，找到空项作为
		\\
		打开文件的句柄
	\end{tabular}  &
	\begin{tabular}{c}
		打开文件
	\end{tabular}  &√  \\ 
	\hline
	(48) &\begin{tabular}{c}
		为打开文件在文件表中寻找一个空闲结
		\\
		构项
	\end{tabular}  &
	\begin{tabular}{c}
		打开文件
	\end{tabular}  &√  \\ 
	\hline
	(49) &\begin{tabular}{c}
		得到文件的inode,根据inode设置文件
		\\
		表指针
	\end{tabular}  &
	\begin{tabular}{c}
		打开文件
	\end{tabular}  &√  \\ 
	\hline
	(50) &\begin{tabular}{c}
		调用sys\_write系统调用，完成syst
		\\
		em\_call中对堆栈的一系列操作
	\end{tabular}  &
	\begin{tabular}{c}
		写入文件
	\end{tabular}  &√  \\ 
	\hline
	(51) &\begin{tabular}{c}
		取出文件inode节点，调用设备写入
		\\
		函数
	\end{tabular}  &
	\begin{tabular}{c}
		写入文件
	\end{tabular}  &√  \\ 
	\hline
	(52) &\begin{tabular}{c}
		Printf调用write,write调用
		\\
		rw\_char最终调用con\_write,根据
		\\
		输入字符类型的不同，控制终端上的光
		\\
		标的变化
	\end{tabular}  &
	\begin{tabular}{c}
		写入文件
	\end{tabular}  &√  \\ 
	\hline
	(53) &\begin{tabular}{c}
		释放当前进程代码段和数据段占有的
		\\
		内存页
	\end{tabular}  &
	\begin{tabular}{c}
		进程退出
	\end{tabular}  &√  \\ 
	\hline
	(54) &\begin{tabular}{c}
		设置其子进程的状态，进程1发送信号
	\end{tabular}  &
	\begin{tabular}{c}
		进程退出
	\end{tabular}  &√  \\ 
	\hline
	(55) &\begin{tabular}{c}
		改变当前进程的状态并通知父进程。
		\\
		执行调度。
	\end{tabular}  &
	\begin{tabular}{c}
		进程退出
	\end{tabular}  &√  \\ 
	\hline
	(56) &\begin{tabular}{c}
		扫描任务数组，并用free\_page
		\\
		释放任务相关页面
	\end{tabular}  &
	\begin{tabular}{c}
		进程释放
	\end{tabular}  &√  \\ 
	\hline
	(57) &\begin{tabular}{c}
		根据请求想的命令对硬盘发送读写命令
		\\
		，调用hd\_out发送信息。
	\end{tabular}  &
	\begin{tabular}{c}
		do\_hd\_request执行
		\\
		硬盘读写请求操作
	\end{tabular}  &√  \\ 
	\hline
	(58) &\begin{tabular}{c}
		检查参数有效性
	\end{tabular}  &
	\begin{tabular}{c}
		硬盘控制器发送操作命令
	\end{tabular}  &√  \\ 
	\hline
	(58) &\begin{tabular}{c}
		设置硬盘中断应当调用的c函数指针
		\\
		do\_hd。
	\end{tabular}  &
	\begin{tabular}{c}
		硬盘控制器发送操作命令
	\end{tabular}  &√  \\ 
	\hline
	(59) &\begin{tabular}{c}
		向控制器端口发送7字节的参数命令块
	\end{tabular}  &
	\begin{tabular}{c}
		硬盘控制器发送操作命令
	\end{tabular}  &√  \\ 
	\hline
	(60) &\begin{tabular}{c}
		进入内核态堆栈，压入寄存器内容，修
		\\
		改ss,es,fs等段寄存器的内容。
	\end{tabular}  &
	\begin{tabular}{c}
		硬盘中断处理程序
	\end{tabular}  &√  \\ 
	\hline
	(61) &\begin{tabular}{c}
		将do\_hd指针放入edx寄存器，根据
		\\
		edx的内容调用函数
	\end{tabular}  &
	\begin{tabular}{c}
		硬盘中断处理程序
	\end{tabular}  &√  \\ 
	\hline
	(62) &\begin{tabular}{c}
		判断写命令操作是否出错，将欲写扇区
		\\
		数减1。若扇区数据写完，调用end\_r
		\\
		equest()处理结束事宜。
	\end{tabular}  &
	\begin{tabular}{c}
		写扇区中断调用函数
	\end{tabular}  &√  \\ 
	\hline
	(63) &\begin{tabular}{c}
		sys\_brk对给定参数end\_data\_seg
		\\
		进行判断，在数值合理情况下设置
		\\
		task\_struct中的brk字段
	\end{tabular}  &
	\begin{tabular}{c}
		数据段末尾设置
	\end{tabular}  &新增  \\ 
	\hline
	(64) &\begin{tabular}{c}
		通过sys\_ioctl进行输入输出之前的
		\\
		相关设置。
	\end{tabular}  &
	\begin{tabular}{c}
		输入输出控制
	\end{tabular}  &新增  \\ 
	\hline
	(65) &\begin{tabular}{c}
		通过sys\_signal设置给定信号的
		\\
		句柄
	\end{tabular}  &
	\begin{tabular}{c}
		信号设置
	\end{tabular}  &新增  \\ 
	\hline
   
\end{longtable} 
%\begin{enumerate}
%    \item[3] 只完成了读取第一个字节
%    \item[] (...)
%\end{enumerate}

\section{界面与操作方法}
可视化界面支持alt+f4关闭，由于该界面的主要目的是绘制一个连贯的动画，所以并没有太强的交互性。程序会展示多个绘图界面，支持用户在主界面内通过断点列表内的滑块，查看之前已经出现的断点。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.25]{cu1}  
	\caption{用户界面}  %图片的名称
	\label{fig3}
\end{figure}
当出现进程线性空间界面时，可以按下draw按钮，绘制如下进程内存相关的信息。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.35]{osss}  
	\caption{内存界面}  %图片的名称
	\label{fig333}
\end{figure}
（此处描述你的可视化界面支持什么操作，比如空格暂停、alt+f4关闭等等，如果有鼠标操作，可附加截图说明）


\chapter{系统运行过程实例}

\section{进程创建}
\subsection{get\_free\_page}
要寻找一个新的物理页面存放copy的task\_struct。get\_free\_page
在mem\_map中找到一个为0的物理页面，将对应内存映像的比特置为1。通过ecx计算出页面实际地址，用edx指向这个物理页面。 设置ecx为1024，将edi指向页面末端，从edi开始清零内存。最后将页面起始地址存入eax.   

\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.25]{oss1}  
	\caption{找空闲物理页面}  %图片的名称
	\label{fig19}
\end{figure}

\subsection{修改task\_struct}
修改复制的task\_struct中的内容,此处仅展示下esp0指向的位置，即为当前物理页面的最后。正好为0xf9000+4096的结果。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.25]{oss2}  
	\caption{修改task\_struct}  %图片的名称
	\label{fig20}
\end{figure}
\subsection{得到GDT表中存放当前LDT的位置，更改线性基地址}
改变task\_struct中tss.ldt的指向，更改原来的线性基地址为当前进程的线性基地址，修改ldt表中的内容.
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss3}  
	\caption{展示GDT和LDT表}  %图片的名称
	\label{fig21}
\end{figure}
\subsection{copy\_page\_tables}
左侧模拟页目录，根据线性地址可以得到左侧的from与to,128与256为在页目录中的索引。copy页表中的内容，让新页表中对应的内存页面只读，若页表所指的物理页面地址在1MB以上，则设置源页表项只读。Copy时候，只复制有效的源目录（即指定的页表存在）项指向的页表。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.35]{oss4}  
	\caption{复制进程页表}  %图片的名称
	\label{fig22}
\end{figure}
\subsection{修改GDT表}
设置GDT表中新建进程的tss段描述符与ldt段描述符。当前的LDT表和TSS段都在之前申请的task\_struct中。且LDT table和TSS section之间间隔24byte,又由于LDT项为8byte,则LDT表和TSS段之间正好间隔3个LDT表项。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{oss5}  
	\caption{设置GDT表}  %图的名称
	\label{fig23}
\end{figure}
\section{进程调度}
\subsection{查找是否有过期的alarm}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.35]{oss6}  
	\caption{遍历alarm}  %图片的名称
	\label{fig24}
\end{figure}
\subsection{找到counter值最大的就绪状态任务}
循环遍历任务，找到counter值最大的就绪状态任务并将循环运行出的结果表现在右侧。小方块的颜色代表了当前进程的状态，绿色为运行状态，灰色为其他状态
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss7}  
	\caption{遍历counter}  %图片的名称
	\label{fig25}
\end{figure}
\subsection{更新counter}
在找不到counter值不为0的就绪状态任务时，根据priority更新所有任务的counter。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss8}  
	\caption{遍历counter}  %图片的名称
	\label{fig26}
\end{figure}

\section{进程execve}
\subsection{通过名字得到inode节点}
采用硬盘中断，取出执行文件的i节点
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss}  
	\caption{遍历counter}  %图片的名称
	\label{fig27}
\end{figure}
\subsection{权限判断}
从task\_struct中得到euid和egid,判断是否改变euid与egid。根据euid与egid的关系右移imode, 右移后的imode低三位作为权限。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss9}  
	\caption{权限判断}  %图片的名称
	\label{fig28}
\end{figure}
\subsection{复制字符串到参数环境空间}
参数空间位于进程逻辑地址的后128kB,参数空间的填写从后往前进行。第一个长方形表示的是整个当前进程的线性地址空间，将参数空间部分放大得到图中所示的parameter space。其中parameter pointer最开始指向参数空间末端。
Tmp为当前需要复制的字符串指针，逆向逐字符将tmp指向的字符串复制到参数和环境空间末端。若p指针指向的线性地址处没有分配页面，则为其申请一页物理内存。将tmp的内容复制到offset处。此时复制字符串是复制到新分配的物理页面。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss10}  
	\caption{copy\_string}  %图片的名称
	\label{fig29}
\end{figure}
\subsection{修改代码段限长并映射物理页面}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss11}  
	\caption{修改段限长}  %图片的名称
	\label{fig30}
\end{figure}
将参数和环境空间中已经存放数据的页面放到数据段末端。从进程线性地址空间末端一页一页映射。映射方法为修改线性地址所指向的页表项的内容，使之指向物理页面。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss12}  
	\caption{映射物理页面到参数地址空间}  %图片的名称
	\label{fig31}
\end{figure}
\subsection{在参数环境空间中设置指针表}
根据copy\_string时的数据表示来划分参数和环境空间。参数环境空间设置完成后，修改eip[0]将原来的返回地址改为执行程序入口，eip[3]指向新的esp的位置。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss13}  
	\caption{创建指针表}  %图片的名称
	\label{fig33}
\end{figure}
\section{进程退出}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{oss15}  
	\caption{子进程挂到进程1下}  %图片的名称
	\label{fig34}
\end{figure}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss30}  
	\caption{进程被父进程释放}  %图片的名称
	\label{fig49}
\end{figure}
\subsection{写保护异常}
根据线性地址找到物理页面
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{oss16}  
	\caption{展示原物理页面}  %图片的名称
	\label{fig35}
\end{figure}
创建一个新的物理页面，让当前线性地址下页表项指向新页面。并设置该页表项中可读写标志。将原页面的内容复制到到新页面上。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{oss17}  
	\caption{复制到新的页面}  %图片的名称
	\label{fig36}
\end{figure}

\subsection{缺页异常}
左侧linear address列展示发生缺页异常的线性地址(会列出当前进程所有发生缺页异常的线性地址)。通过get\_free\_page得到一个新的物理页面，等待存入从硬盘读入数据。根据偏移地址，计算得到文件系统中的首个块号。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.4]{oss18}  
	\caption{创建新页面}  %图片的名称
	\label{fig37}
\end{figure}
根据首个块号通过bmap得到对应的磁盘中的四个块号。右侧展示了当前读入的磁盘块号。通过do\_hd\_request和hd\_out从磁盘读入数据。箭头表示读取该块时的设备号与磁头号。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss19}  
	\caption{}  %图片的名称
	\label{fig38}
\end{figure}
四个数据块读入物理页面后，将线性地址对应的页表项指向该物理页面。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.35]{oss20}  
	\caption{}  %图片的名称
	\label{fig39}
\end{figure}
\section{系统调用}
进入系统调用时，向栈中先压入ss，esp,eflags,cs,eip等值，进入system
\_call之后，压入其他段寄存器和通用寄存器的值。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss21}  
	\caption{系统调用开始}  %图片的名称
	\label{fig40}
\end{figure}
系统调用结束后查看当前进程的状态和时间片剩余情况，判断是继续进行ret\_from\_sys\_call还是reschedule。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss22}  
	\caption{系统调用结束} %图片的名称
	\label{fig41}
\end{figure}
进行ret\_from\_sys\_call判断当前任务是否为任务0，以及是否是用户任务。判断完成后取信号位图入ebx,阻塞位图入ecx,对ebx和ecx进行一系列操作，最后ecx中存储为1的位的偏移值。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss23}  
	\caption{ret\_from\_sys\_call} %图片的名称
	\label{fig42}
\end{figure}
\section{信号设置}
在栈右侧区域显示通过sys\_signal系统调用设置句柄的信号的名称。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss24}  
	\caption{信号设置} %图片的名称
	\label{fig43}
\end{figure}
\section{输入输出控制}
展示输入输出控制时候的判断过程。
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss25}  
	\caption{输入输出控制} %图片的名称
	\label{fig44}
\end{figure}
\section{写操作}
展示当前写操作调用的函数(根据调用的函数了解执行的具体操作)
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss26}  
	\caption{写终端} %图片的名称
	\label{fig45}
\end{figure}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss27}  
	\caption{写文件} %图片的名称
	\label{fig46}
\end{figure}
\section{打开文件}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss28}  
	\caption{打开文件} %图片的名称
	\label{fig47}
\end{figure}
\section{数据段末尾设置}
\begin{figure}[H]%H表示图强制在下面，想设置浮动环境用htp
	\centering  %插入的图片居中表示
	\includegraphics[scale=0.3]{oss29}  
	\caption{数据段末尾设置} %图片的名称
	\label{fig48}
\end{figure}

\chapter{Linux0.11系统源代码分析}


\section{系统调用}
系统调用是用户程序和操作系统内核交互的接口，可以通过观察程序进行了哪些系统调用，了解操作系统为程序做了哪些事情。\\

系统调用的核心为system\_call.s程序，每个系统调用发生时都会先进入\_system\_call过程，将段寄存器和一些通用寄存器的值入栈，然后通过\_sys\_call\_table间接调用指定的某个功能的函数。不同的处理函数可能进一步调用不同的函数来完成系统调用的功能。而每个系统调用又会返回\_system\_call过程进行结束或者reschedule处理。可以观察每次进入\_system\_call的功能号，而判断操作系统接下来要进行的操作。通过call \_sys\_call\_table调用返回判断一个系统调用的结束，而后了解系统调用结束时，操作系统需要做的事情。\\

本实验展示的过程中涉及sys\_fork, sys\_signal, sys\_execve, sys\_open, sys\_ioctl, sys\_brk, sys\_write, sys\_exit, sys\_close, sys\_waitpid系统调用。

\section{内存管理}
进程控制和内存管理紧密相关，进程创建的过程中会通过内存管理得到存放task\_struct的页面，会由于写保护异常而需要内存管理处理；进程运行过程中会产生缺页异常；进程execve时，需要内存管理来复制页面，释放页表等。\\

内存管理的核心代码位于memory.c中，涉及对物理地址空间和线性地址空间的操作。page.s调用memory.c中的代码处理缺页异常和写保护异常。get\_free\_page通过mem\_map找到一个值为0的项，从而找到对应的物理页面，清零这个物理页面，将物理页面起始地址作为返回值。copy\_page\_tables完成对页表的复制，输入from基地址和to基地址，根据线性地址的结构得到对应的页目录项，和页目录项指向的页表；为to的页表项创建分配物理页面存储页表，复制from页目录项指向的页表到新页表中，并设置内存页面的只读性质。\\
\subsection{写保护异常}
do\_wp\_page通过调用un\_wp\_page处理写保护异常。un\_wp\_page判断产生异常的页面是否被共享，为共享的页面申请一个空的物理页面，使页表指向新的物理页面，并调用copy\_page将原页面复制到新的物理页面上。\\

\subsection{缺页异常}
发生缺页异常时，page\_fault会调用do\_no\_page处理，根据缺页的线性地址得到在线性地址空间中相对于进程基址的偏移，从而判断缺页是否在当前进程范围内。若在范围内则判断是否为共享页面，若不是则申请一页新的物理页面。从文件中读入四个数据块到当前物理页面中，然后调用put\_page将新的物理页面映射到缺页线性地址处。put\_page根据线性地址计算处所在的页目录项，得到页表地址和对应的页表项，修改页表项的内容。

\section{进程控制}
进程控制主要包含进程创建，进程execve，进程exit三个部分。这三个操作各自对应一个系统调用，且这三个过程都和内存密切相关。每个进程根据其任务号在线性地址空间中对应一连续的内存空间，进程控制时常需要对这个空间进行操作，进程运行时的代码和数据也都来源于内存。在本实验中选取的展示过程中包含了这三个部分，希望能够采用可视化的手段展示出进程控制和内存管理之间的关系。\\

\subsection{进程创建}
进程创建的核心代码为fork.c中的函数，fork时需要先分配一个任务号和pid，再复制父进程的task\_struct到一个新的物理页面，并根据子进程的状况对复制的tsak\_struct进行一定的修改。利用copy\_page\_tables复制父进程的页表到子进程处，修改GDT表，加入新的TSS和LDT段描述符。最后将子进程的状态设置为TASK\_RUNNING。\\

\subsection{进程execve}
进程execve的核心代码为exec.c中的do\_execve。首先判断是否有访问文件的权限，然后读出执行文件头部的数据，根据数据进行判断，从而选择应当执行的操作。当执行文件不是脚本文件时，do\_execve需要对文件格式，文件大小，是否有重定位部分，是否从页边界开始进行判断。若经判断没有错误，则继续进行对参数环境空间的操作。\\

参数环境空间位于当前进程对应的线性地址空间的后128kb内，对参数环境空间的操作涉及内存管理。调用copy\_strings将指定个数的参数字符串复制到参数环境空间中。对某个字符串复制的方法为:根据参数环境空间指针p，得到p所在的页在线性空间中的位置，判断该页是否存在，若不存在则为该线性地址空间中的页面分配一个空的物理页面。将字符串中的字符逐个逆向复制到物理页面上p所指向的位置，并在复制的过程中不断更新p的值。循环整个过程，逆向复制各个参数到指定的偏移地址处。\\

对tesk\_struct进行一系列设置操作后。通过free\_page\_tables释放原来的页和页表指向的物理页面。调用change\_ldt修改代码段限长，将之前copy\_strings被复制了信息的物理页面通过put\_page映射到对应的线性地址处，即真正将参数环境空间放在了数据段末端。此时p也变为相对于数据段起始处的指针。\\

调用create\_tables在线性地址空间中为环境变量和参数字符串创建指针。根据p指针和参数个数，环境变量个数，得到存放指针的空间。之后将envp,argv,argc压入后续空间中。最后将各个参数环境变量指针放入之前得到的指针空间中。\\

其后完成对task\_struct中的值进行修改等操作后，将create\_table中envp,argv,argc压入后的起始处设置为esp。将代码指针替换为新的执行程序入口。

\subsection{进程exit}
进程exit的核心代码为exit.c中的do\_exit函数。该函数主要做的事情就是释放当前晋城市uo占用的一系列资源，包括内存相关资源\\

首先调用free\_page\_tables释放进程页与页表。将当前进程的子进程挂在init进程下，并在子进程僵死时，向进程1发送那个SIGCHLD信号。完成对文件系统资源的释放，根据在会话中的低位释放资源。设置当前进程僵死并设置退出码。通过tell\_father告知父进程当前进程将停止。最后调用schedule()。进程最终被父进程release之后才是真正被完全释放掉。

\subsection{进程调度}
进程调度的原因多种多样，最常见原因为：时间片用尽，进程exit时的schedule()，进程release时的schedule()。进程调度的核心代码为sched.c中的schedule函数，schedule函数的功能主要是选择下一个将要转到的状态。\\

schedule通过遍历任务数组，检测是否有alarm过时的进程，若有则向任务发送SIGALARM信号；检测是否在任务处于可中断状态时有非阻塞信号，若有则将进程状态变为就绪。之后循环检测每个就绪状态任务的counter值，找到最大且不为0的counter值，转到该值对应的进程。若没有非0状态，则根据优先级和当前counter重设每个任务的counter值，之后再济宁比较，找到应当转到的状态。

\section{其他操作}
\subsubsection{硬盘操作}
硬盘是计算机的外存，操作系统的内存资源有限，故而常常需要从硬盘读取数据。从硬盘读取数据时会调用hd.c中的do\_hd\_request处理硬盘当前请求。do\_hd\_request用于检查请求项的合法性，根据当前的设备号和扇区号信息计算出在对应硬盘上的位置。根据当前请求的类型，通过hd\_out向硬盘控制器发送读或者写命令。hd\_out用于向硬盘控制器发送命令块，其中会设置do\_hd函数指针，该函数会在中断程序中被调用，该函数指针的值不是固定的，是hd\_out的输入参数。可以根据do\_hd指针的类型，了解要对硬盘进行什么操作。
\subsubsection{信号设置}
sys\_signal位于signal.c中，用于为指定的信号安装信号句柄。先根据signum判断信号值是否有效，若有效则根据参数组件新的sigcation结构。取出原信号处理句柄作为返回值，将新的句柄设置到task\_struct的sigcation数组中的对应位置。
\subsubsection{写文件}
写文件时调用read\_write.c中的sys\_write系统调用。该系统调用先判断文件句柄的的有效性，若有效则根据i节点，调用不同文件类型对应的读操作函数。
\subsubsection{数据段末尾设置}
系统调用处理函数sys\_brk位于sys.c中用于对给定的参数end\_data\_seg进行判断，在数值合理的情况下更新task\_struct中的brk字段为end\_data\_seg。
\subsubsection{输入输出控制}
sys\_ioctl位于ioctl.c程序中，用于进行输入输出控制。在进程进行输入输出之前需要调用该函数先进行相关设置。该函数对文件描述符有效性和文件类型进行判断，若都可行则从文件的i节点得到设备号，查表找到该设备对应到函数指针并调用。

\section{与现在的linux的比较}
linux0.11的内存中为了简洁，同一进程的代码段和数据段基地址限制为相同的，而在现在的linux中并没有这个限制。linux0.11中查找页表是直接从内存中的页目录项中读取页表所在的物理地址，从而查找页表，而现在的linux中往往先查找TLB表，若没有命中，再查内存中的页表。linux0.11的内存管理是比较低效的，例如get\_free\_page的时候需要遍历整个内存位图。现在的linux为内存管理开发了比较高效和灵活的方式，出现了slab分配器，slob，slub等。linux0.11的进程调度是通过schedule()中比较每个任务的counter,而现在的linux系统有更多样的调度算法，包括短作业优先，多级反馈队列调度算法等。
\end{document}          
